name: Web Calculator

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  GITHUB_USERNAME: ${{ github.repository_owner }}

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        python-version: ['3.10', '3.11', '3.12']
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run unit tests with pytest
      run: |
        python -m pytest tests/unit_tests/ -v --junitxml=junit-unit-${{ matrix.python-version }}.xml --cov=calculator --cov-report=xml
    
    - name: Run functional tests
      run: |
        # å¯åŠ¨åº”ç”¨
        python app.py &
        APP_PID=$!
        
        # ç­‰å¾…åº”ç”¨å¯åŠ¨
        sleep 10
        
        # è¿è¡ŒåŠŸèƒ½æµ‹è¯•
        python -m pytest tests/functional_tests/ -v --junitxml=junit-func-${{ matrix.python-version }}.xml
        
        # åœæ­¢åº”ç”¨
        kill $APP_PID
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.python-version }}
        path: |
          junit-*.xml
          coverage.xml
        retention-days: 7

  verify-image-push:
    name: Verify Image Push
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/tags/'))
    
    steps:
    - name: Login to GHCR
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.CR_PAT }}
    
    - name: Check image in registry
      run: |
        # è·å–çŸ­ SHA
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        IMAGE_TAG="sha-$SHORT_SHA"
        FULL_IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG"
        
        echo "ğŸ” Checking image: $FULL_IMAGE_NAME"
        
        # ä½¿ç”¨ crane æˆ– curl æ£€æŸ¥é•œåƒæ˜¯å¦å­˜åœ¨
        if which crane >/dev/null 2>&1; then
          crane digest $FULL_IMAGE_NAME && echo "âœ… Image exists (checked with crane)"
        else
          # ä½¿ç”¨ curl æ£€æŸ¥ GHCR API
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer $(echo -n ${{ secrets.CR_PAT }} | base64)" \
            "https://ghcr.io/v2/${{ github.repository }}/manifests/$IMAGE_TAG")
          
          if [ "$RESPONSE" = "200" ]; then
            echo "âœ… Image exists in registry (HTTP 200)"
          else
            echo "âŒ Image not found (HTTP $RESPONSE)"
            echo "Available tags:"
            curl -s -H "Authorization: Bearer $(echo -n ${{ secrets.CR_PAT }} | base64)" \
              "https://ghcr.io/v2/${{ github.repository }}/tags/list" | jq . || true
            exit 1
          fi
        fi

  build:
    name: Build and Push Docker Image
    needs: [test, verify-image-push]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/tags/'))
  
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.CR_PAT }}
    
    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=sha,prefix={{branch}}-,format=short
          type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          GIT_COMMIT=${{ github.sha }}
    
    - name: Verify push with retry
      if: github.event_name != 'pull_request'
      run: |
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        IMAGE_TAG="sha-$SHORT_SHA"
        FULL_IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG"
        
        echo "ğŸ” Verifying image push: $FULL_IMAGE_NAME"
        
        # é‡è¯•æœºåˆ¶
        max_retries=5
        retry_count=0
        
        while [ $retry_count -lt $max_retries ]; do
          echo "Attempt $((retry_count + 1)) of $max_retries"
          
          if docker pull $FULL_IMAGE_NAME 2>/dev/null; then
            echo "âœ… Successfully pulled image after $((retry_count + 1)) attempts"
            echo "Image details:"
            docker inspect $FULL_IMAGE_NAME --format='{{.RepoTags}} {{.Size}}'
            break
          else
            echo "âš ï¸ Pull failed, retrying in 3 seconds..."
            retry_count=$((retry_count + 1))
            sleep 3
          fi
        done
        
        if [ $retry_count -eq $max_retries ]; then
          echo "âŒ Failed to verify image push after $max_retries attempts"
          
          # åˆ—å‡ºå¯ç”¨çš„é•œåƒæ ‡ç­¾
          echo "Available tags for ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:"
          curl -s -H "Authorization: Bearer $(echo -n ${{ secrets.CR_PAT }} | base64)" \
            "https://ghcr.io/v2/${{ github.repository }}/tags/list" | jq -r '.tags[]' | head -20 || true
          
          exit 1
        fi

  pre-deploy-check:
    name: Pre-Deployment Checks
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: Generate deployment tag
      id: vars
      run: |
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
        echo "DEPLOY_TAG=sha-$SHORT_SHA" >> $GITHUB_ENV
        echo "IMAGE_FULL_NAME=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-$SHORT_SHA" >> $GITHUB_ENV
        
        echo "ğŸ“‹ Deployment Info:"
        echo "SHA: ${{ github.sha }}"
        echo "Short SHA: $SHORT_SHA"
        echo "Deploy Tag: sha-$SHORT_SHA"
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-$SHORT_SHA"
    
    - name: Test VM connectivity
      env:
        VM_USER: ${{ secrets.VM_USER || 'ubuntu' }}
        VM_HOST: ${{ secrets.VM_HOST }}
        VM_PASSWORD: ${{ secrets.VM_PASSWORD }}
      run: |
        echo "ğŸ”Œ Testing VM connectivity..."
        
        # æµ‹è¯•åŸºæœ¬è¿æ¥
        if ping -c 3 -W 2 "$VM_HOST" > /dev/null 2>&1; then
          echo "âœ… Ping successful"
        else
          echo "âš ï¸ Ping failed, continuing anyway..."
        fi
        
        # æµ‹è¯• SSH è¿æ¥
        echo "Testing SSH connection..."
        timeout 30s sshpass -p "$VM_PASSWORD" ssh \
          -o StrictHostKeyChecking=no \
          -o ConnectTimeout=10 \
          -o BatchMode=yes \
          -o ServerAliveInterval=60 \
          "$VM_USER@$VM_HOST" \
          "echo 'SSH connection successful'; date; uptime"
        
        if [ $? -eq 0 ]; then
          echo "âœ… SSH connection established"
        else
          echo "âŒ SSH connection failed"
          exit 1
        fi
    
    - name: Check VM Docker status
      env:
        VM_USER: ${{ secrets.VM_USER || 'ubuntu' }}
        VM_HOST: ${{ secrets.VM_HOST }}
        VM_PASSWORD: ${{ secrets.VM_PASSWORD }}
      run: |
        echo "ğŸ³ Checking Docker status on VM..."
        
        sshpass -p "$VM_PASSWORD" ssh \
          -o StrictHostKeyChecking=no \
          "$VM_USER@$VM_HOST" "
          echo '=== Docker Status ==='
          sudo systemctl status docker --no-pager | head -20
          echo ''
          echo '=== Docker Version ==='
          docker version --format 'Client: {{.Client.Version}}, Server: {{.Server.Version}}' 2>/dev/null || echo 'Docker not available'
          echo ''
          echo '=== Disk Space ==='
          df -h / /var/lib/docker
        "
    
    - name: Test GHCR access from VM
      env:
        VM_USER: ${{ secrets.VM_USER || 'ubuntu' }}
        VM_HOST: ${{ secrets.VM_HOST }}
        VM_PASSWORD: ${{ secrets.VM_PASSWORD }}
        CR_PAT: ${{ secrets.CR_PAT }}
      run: |
        echo "ğŸŒ Testing GHCR access from VM..."
        
        sshpass -p "$VM_PASSWORD" ssh \
          -o StrictHostKeyChecking=no \
          "$VM_USER@$VM_HOST" "
          set -e
          
          echo '1. Testing network connectivity...'
          if curl -s --max-time 5 https://ghcr.io > /dev/null; then
            echo 'âœ… GHCR is reachable'
          else
            echo 'âŒ Cannot reach GHCR'
            echo 'Trying with different methods:'
            curl -I --max-time 5 https://ghcr.io || true
            nslookup ghcr.io || true
          fi
          
          echo ''
          echo '2. Testing Docker login...'
          if echo '$CR_PAT' | docker login ghcr.io -u '${{ github.actor }}' --password-stdin; then
            echo 'âœ… Docker login successful'
            
            echo ''
            echo '3. Testing image pull...'
            # å…ˆå°è¯•æ‹‰å–ä¸€ä¸ªå…¬å…±é•œåƒæµ‹è¯•
            if docker pull hello-world:latest; then
              echo 'âœ… Can pull public images'
            else
              echo 'âŒ Cannot pull public images'
            fi
            
            # å°è¯•åˆ—å‡ºæˆ‘ä»¬çš„é•œåƒï¼ˆå¯èƒ½å¤±è´¥ï¼Œä½†ä¸é€€å‡ºï¼‰
            echo ''
            echo '4. Checking for existing images...'
            docker images | grep web-calculator || echo 'No web-calculator images found locally'
            
          else
            echo 'âŒ Docker login failed'
            echo 'Possible issues:'
            echo '- Token might be expired'
            echo '- Token lacks required permissions'
            echo '- Network/proxy issues'
          fi
          
          # é€€å‡ºç™»å½•ï¼Œé¿å…ç•™ä¸‹å‡­è¯
          docker logout ghcr.io 2>/dev/null || true
        "

  deploy:
    name: Blue-Green Deployment
    needs: [build, pre-deploy-check]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    environment:
      name: production
      url: http://${{ secrets.VM_HOST }}
    
    steps:
    - name: Install sshpass for password login
      run: |
        sudo apt-get update
        sudo apt-get install -y sshpass
    
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Prepare enhanced deployment script
      run: |
        cat > deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "ğŸš€ Starting blue-green deployment..."
        echo "ğŸ“¦ Image: ${{ env.IMAGE_FULL_NAME }}"
        echo "ğŸ·ï¸  Deploy tag: ${{ env.DEPLOY_TAG }}"
        
        cd /opt/web-calculator
        
        # ç¡®ä¿ Docker Compose æ–‡ä»¶å­˜åœ¨
        if [ ! -f docker-compose.yml ]; then
          echo "âŒ docker-compose.yml not found in /opt/web-calculator"
          ls -la /opt/web-calculator/
          exit 1
        fi
        
        # æ£€æŸ¥å½“å‰æ´»åŠ¨é¢œè‰²
        if docker-compose ps app_blue 2>/dev/null | grep -q "Up" && \
           grep -q "max_fails" nginx/conf.d/default.conf 2>/dev/null | grep -q "app_blue"; then
          CURRENT_COLOR="blue"
          NEXT_COLOR="green"
        else
          CURRENT_COLOR="green"
          NEXT_COLOR="blue"
        fi
        
        echo "ğŸ¯ Current active: $CURRENT_COLOR"
        echo "ğŸ¯ Deploying to: $NEXT_COLOR"
        
        # åˆ›å»ºæˆ–æ›´æ–°ç¯å¢ƒå˜é‡æ–‡ä»¶
        cat > .env << EOL
        GITHUB_USERNAME=${{ env.GITHUB_USERNAME }}
        DEPLOY_TAG=${{ env.DEPLOY_TAG }}
        IMAGE_FULL_NAME=${{ env.IMAGE_FULL_NAME }}
        EOL
        
        if [ "$NEXT_COLOR" = "blue" ]; then
          echo "BLUE_TAG=${{ env.DEPLOY_TAG }}" >> .env
          echo "GREEN_TAG=latest" >> .env
        else
          echo "BLUE_TAG=latest" >> .env
          echo "GREEN_TAG=${{ env.DEPLOY_TAG }}" >> .env
        fi
        
        echo "ğŸ“„ Environment file created:"
        cat .env
        
        # ç™»å½•åˆ° GitHub Container Registry
        echo "ğŸ” Logging into GHCR..."
        if echo '${{ secrets.CR_PAT }}' | docker login ghcr.io -u '${{ github.actor }}' --password-stdin; then
          echo "âœ… Successfully logged into GHCR"
        else
          echo "âŒ Failed to login to GHCR"
          
          # å°è¯•ä½¿ç”¨å¤‡é€‰æ–¹æ³•
          echo "Trying alternative login method..."
          docker logout ghcr.io 2>/dev/null || true
          echo '${{ secrets.CR_PAT }}' | base64 -d | docker login ghcr.io -u '${{ github.actor }}' --password-stdin || {
            echo "All login attempts failed"
            exit 1
          }
        fi
        
        # éªŒè¯é•œåƒå­˜åœ¨æ€§
        echo "ğŸ” Verifying image exists in registry..."
        MAX_RETRIES=5
        IMAGE_FOUND=false
        
        for i in $(seq 1 $MAX_RETRIES); do
          echo "Attempt $i/$MAX_RETRIES to verify image..."
          
          if docker manifest inspect "${{ env.IMAGE_FULL_NAME }}" > /dev/null 2>&1; then
            echo "âœ… Image found in registry"
            IMAGE_FOUND=true
            break
          else
            echo "âš ï¸ Image not found, retrying in 2 seconds..."
            sleep 2
          fi
        done
        
        if [ "$IMAGE_FOUND" = false ]; then
          echo "âŒ Image ${{ env.IMAGE_FULL_NAME }} not found after $MAX_RETRIES attempts"
          echo "Available tags for ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:"
          
          # å°è¯•åˆ—å‡ºå¯ç”¨æ ‡ç­¾
          curl -s -H "Authorization: Bearer $(echo -n '${{ secrets.CR_PAT }}' | base64)" \
            "https://ghcr.io/v2/${{ github.repository }}/tags/list" 2>/dev/null | \
            jq -r '.tags[]' 2>/dev/null | head -10 || echo "Could not list tags"
          
          # å°è¯•æ‹‰å– latest ä½œä¸ºå¤‡é€‰
          echo "Trying to pull latest tag instead..."
          LATEST_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          if docker manifest inspect "$LATEST_IMAGE" > /dev/null 2>&1; then
            echo "âœ… Latest image found, using it instead"
            sed -i "s|${{ env.DEPLOY_TAG }}|latest|g" .env
          else
            echo "âŒ No suitable image found"
            exit 1
          fi
        fi
        
        # æ‹‰å–æ–°é•œåƒï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
        echo "â¬‡ï¸  Pulling new image for app_${NEXT_COLOR}..."
        PULL_SUCCESS=false
        
        for i in $(seq 1 3); do
          echo "Pull attempt $i/3..."
          if docker-compose pull app_${NEXT_COLOR}; then
            echo "âœ… Image pulled successfully"
            PULL_SUCCESS=true
            break
          else
            echo "âš ï¸ Pull failed, retrying in 3 seconds..."
            sleep 3
          fi
        done
        
        if [ "$PULL_SUCCESS" = false ]; then
          echo "âŒ Failed to pull image after 3 attempts"
          echo "Trying direct docker pull..."
          
          if [ "$NEXT_COLOR" = "blue" ]; then
            IMAGE_TO_PULL=$(grep BLUE_TAG .env | cut -d= -f2)
          else
            IMAGE_TO_PULL=$(grep GREEN_TAG .env | cut -d= -f2)
          fi
          
          FULL_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TO_PULL"
          echo "Pulling $FULL_IMAGE directly..."
          
          if docker pull "$FULL_IMAGE"; then
            echo "âœ… Direct pull successful"
          else
            echo "âŒ All pull attempts failed"
            exit 1
          fi
        fi
        
        # æ˜¾ç¤ºæ‹‰å–çš„é•œåƒ
        echo "ğŸ“‹ Pulled images:"
        docker images | grep "${{ env.IMAGE_NAME }}" | head -5
        
        # å¯åŠ¨æ–°ç‰ˆæœ¬
        echo "ğŸš€ Starting new version (app_${NEXT_COLOR})..."
        docker-compose up -d app_${NEXT_COLOR}
        
        # ç­‰å¾…å¥åº·æ£€æŸ¥
        echo "ğŸ¥ Waiting for health check..."
        MAX_RETRIES=30
        HEALTHY=false
        
        for i in $(seq 1 $MAX_RETRIES); do
          echo "Health check attempt $i/$MAX_RETRIES..."
          
          if docker-compose ps app_${NEXT_COLOR} 2>/dev/null | grep -q "(healthy)"; then
            echo "âœ… New version is healthy"
            HEALTHY=true
            break
          fi
          
          # æ£€æŸ¥å®¹å™¨çŠ¶æ€
          CONTAINER_STATUS=$(docker-compose ps app_${NEXT_COLOR} 2>/dev/null | tail -1)
          echo "Container status: $CONTAINER_STATUS"
          
          if echo "$CONTAINER_STATUS" | grep -q "Exit\|exited"; then
            echo "âŒ Container exited, checking logs..."
            docker-compose logs app_${NEXT_COLOR} | tail -20
            exit 1
          fi
          
          if [ $i -eq $MAX_RETRIES ]; then
            echo "âŒ Health check failed after $MAX_RETRIES attempts"
            echo "Container logs:"
            docker-compose logs app_${NEXT_COLOR} | tail -30
            exit 1
          fi
          
          sleep 2
        done
        
        if [ "$HEALTHY" = false ]; then
          echo "âš ï¸ Health check inconclusive, but proceeding..."
        fi
        
        # åˆ‡æ¢æµé‡
        echo "ğŸ”„ Switching traffic..."
        
        # å¤‡ä»½åŸå§‹é…ç½®
        cp nginx/conf.d/default.conf nginx/conf.d/default.conf.backup
        
        if [ "$NEXT_COLOR" = "green" ]; then
          sed -i 's/server app_blue:5000 max_fails=1 fail_timeout=5s;/server app_blue:5000;/' nginx/conf.d/default.conf
          sed -i 's/server app_green:5000;/server app_green:5000 max_fails=1 fail_timeout=5s;/' nginx/conf.d/default.conf
        else
          sed -i 's/server app_green:5000 max_fails=1 fail_timeout=5s;/server app_green:5000;/' nginx/conf.d/default.conf
          sed -i 's/server app_blue:5000;/server app_blue:5000 max_fails=1 fail_timeout=5s;/' nginx/conf.d/default.conf
        fi
        
        echo "ğŸ“ New nginx configuration:"
        grep "server app_" nginx/conf.d/default.conf
        
        # é‡æ–°åŠ è½½Nginx
        echo "ğŸ”„ Reloading nginx..."
        if docker-compose exec -T proxy nginx -s reload; then
          echo "âœ… Nginx reloaded successfully"
        else
          echo "âš ï¸ Nginx reload failed, trying restart..."
          docker-compose restart proxy
        fi
        
        # ç­‰å¾…æ—§ç‰ˆæœ¬åœæ­¢
        echo "â³ Waiting before stopping old version..."
        sleep 30
        
        echo "ğŸ›‘ Stopping old version (app_${CURRENT_COLOR})..."
        docker-compose stop app_${CURRENT_COLOR} || echo "Warning: Could not stop old version"
        
        # éªŒè¯éƒ¨ç½²
        echo "âœ… Verifying deployment..."
        sleep 10
        
        MAX_VERIFY_RETRIES=10
        for i in $(seq 1 $MAX_VERIFY_RETRIES); do
          echo "Verification attempt $i/$MAX_VERIFY_RETRIES..."
          
          if curl -f -s -o /dev/null -w "%{http_code}" --max-time 5 http://localhost/health; then
            RESPONSE_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 http://localhost/health)
            if [ "$RESPONSE_CODE" = "200" ]; then
              echo "âœ… Deployment successful! (HTTP 200)"
              echo "ğŸ‰ Active version: $NEXT_COLOR"
              echo "ğŸ–¼ï¸  Using image: ${{ env.IMAGE_FULL_NAME }}"
              break
            else
              echo "âš ï¸ Health check returned HTTP $RESPONSE_CODE"
            fi
          else
            echo "âš ï¸ Health check failed, retrying..."
          fi
          
          if [ $i -eq $MAX_VERIFY_RETRIES ]; then
            echo "âŒ Deployment verification failed after $MAX_VERIFY_RETRIES attempts"
            echo "Last curl attempt failed"
          fi
          
          sleep 3
        done
        
        # æ¸…ç†æ—§çš„é•œåƒ
        echo "ğŸ§¹ Cleaning up old images..."
        docker image prune -f --filter "until=24h" || echo "Image prune failed"
        
        # ç™»å‡º GHCR
        docker logout ghcr.io 2>/dev/null || true
        
        echo "âœ¨ Deployment process completed!"
        EOF
        
        chmod +x deploy.sh
        echo "ğŸ“‹ Deployment script created with $(wc -l deploy.sh | cut -d' ' -f1) lines"
    
    - name: Copy files to VM
      env:
        VM_USER: ${{ secrets.VM_USER || 'ubuntu' }}
        VM_HOST: ${{ secrets.VM_HOST }}
        VM_PASSWORD: ${{ secrets.VM_PASSWORD }}
      run: |
        echo "ğŸ“¤ Copying files to VM..."
        
        # åˆ›å»ºå¿…è¦çš„ç›®å½•ç»“æ„
        sshpass -p "$VM_PASSWORD" ssh \
          -o StrictHostKeyChecking=no \
          "$VM_USER@$VM_HOST" "
          sudo mkdir -p /opt/web-calculator/nginx/conf.d
          sudo chown -R $VM_USER:$VM_USER /opt/web-calculator
          ls -la /opt/web-calculator/
        "
        
        # å¤åˆ¶éƒ¨ç½²è„šæœ¬
        echo "Copying deploy.sh..."
        sshpass -p "$VM_PASSWORD" scp \
          -o StrictHostKeyChecking=no \
          -o ConnectTimeout=10 \
          deploy.sh "$VM_USER@$VM_HOST:/tmp/deploy.sh"
        
        # å¤åˆ¶ docker-compose.yml
        if [ -f "docker-compose.yml" ]; then
          echo "Copying docker-compose.yml..."
          sshpass -p "$VM_PASSWORD" scp \
            -o StrictHostKeyChecking=no \
            -o ConnectTimeout=10 \
            docker-compose.yml "$VM_USER@$VM_HOST:/opt/web-calculator/"
        fi
        
        # å¤åˆ¶ nginx é…ç½®
        if [ -f "nginx/conf.d/default.conf" ]; then
          echo "Copying nginx configuration..."
          sshpass -p "$VM_PASSWORD" scp \
            -o StrictHostKeyChecking=no \
            -o ConnectTimeout=10 \
            nginx/conf.d/default.conf "$VM_USER@$VM_HOST:/opt/web-calculator/nginx/conf.d/"
        fi
        
        echo "âœ… Files copied successfully"
    
    - name: Execute deployment
      env:
        VM_USER: ${{ secrets.VM_USER || 'ubuntu' }}
        VM_HOST: ${{ secrets.VM_HOST }}
        VM_PASSWORD: ${{ secrets.VM_PASSWORD }}
      run: |
        echo "ğŸš€ Executing deployment on $VM_USER@$VM_HOST..."
        
        set -x
        
        # æ‰§è¡Œéƒ¨ç½²è„šæœ¬ï¼Œå¸¦æœ‰è¯¦ç»†è¾“å‡º
        sshpass -p "$VM_PASSWORD" ssh \
          -o StrictHostKeyChecking=no \
          -o ConnectTimeout=30 \
          -o ServerAliveInterval=60 \
          -o ServerAliveCountMax=10 \
          "$VM_USER@$VM_HOST" "
          set -e
          echo '=== Starting deployment script ==='
          cat /tmp/deploy.sh | head -20
          echo '...'
          bash /tmp/deploy.sh
        "
        
        DEPLOY_EXIT_CODE=$?
        
        if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
          echo "âœ… Deployment executed successfully"
        else
          echo "âŒ Deployment failed with exit code $DEPLOY_EXIT_CODE"
          
          # è·å–å¤±è´¥æ—¥å¿—
          echo "=== Checking deployment logs ==="
          sshpass -p "$VM_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            "$VM_USER@$VM_HOST" "
            echo '=== Last 50 lines of docker logs ==='
            docker-compose logs --tail=50 2>/dev/null || echo 'Could not get docker logs'
            echo ''
            echo '=== Docker container status ==='
            docker-compose ps 2>/dev/null || docker ps | grep web-calculator || true
          "
          
          exit $DEPLOY_EXIT_CODE
        fi
    
    - name: Create rollback script on VM
      env:
        VM_USER: ${{ secrets.VM_USER || 'ubuntu' }}
        VM_HOST: ${{ secrets.VM_HOST }}
        VM_PASSWORD: ${{ secrets.VM_PASSWORD }}
      run: |
        echo "ğŸ”„ Creating rollback script..."
        
        cat > rollback.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "ğŸ”™ Starting rollback procedure..."
        
        cd /opt/web-calculator
        
        if [ ! -f "nginx/conf.d/default.conf.backup" ]; then
          echo "âŒ No backup configuration found"
          echo "Current configuration:"
          grep "server app_" nginx/conf.d/default.conf || true
          exit 1
        fi
        
        echo "ğŸ“‹ Restoring nginx configuration from backup..."
        cp nginx/conf.d/default.conf.backup nginx/conf.d/default.conf
        
        echo "ğŸ”„ Reloading nginx..."
        docker-compose exec -T proxy nginx -s reload || docker-compose restart proxy
        
        # ç¡®å®šè¦å¯åŠ¨å“ªä¸ªç‰ˆæœ¬
        if grep -q "app_blue.*max_fails" nginx/conf.d/default.conf; then
          START_COLOR="blue"
          STOP_COLOR="green"
        else
          START_COLOR="green"
          STOP_COLOR="blue"
        fi
        
        echo "ğŸš€ Starting $START_COLOR version..."
        docker-compose start app_${START_COLOR} || docker-compose up -d app_${START_COLOR}
        
        echo "ğŸ›‘ Stopping $STOP_COLOR version..."
        docker-compose stop app_${STOP_COLOR} 2>/dev/null || true
        
        echo "âœ… Rollback completed to $START_COLOR version"
        
        # éªŒè¯
        sleep 5
        echo "ğŸ” Verifying rollback..."
        curl -s -o /dev/null -w "HTTP: %{http_code}\n" http://localhost/health || echo "Health check failed"
        EOF
        
        chmod +x rollback.sh
        
        # å¤åˆ¶åˆ° VM
        sshpass -p "$VM_PASSWORD" scp \
          -o StrictHostKeyChecking=no \
          rollback.sh "$VM_USER@$VM_HOST:/opt/web-calculator/rollback.sh"
        
        echo "âœ… Rollback script created and copied"

  notification:
    name: Send Notification
    needs: [test, build, pre-deploy-check, deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Determine deployment status
      id: check-status
      run: |
        if ${{ needs.deploy.result == 'success' }}; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "message=âœ… CI/CD Pipeline completed successfully!" >> $GITHUB_OUTPUT
        elif ${{ needs.deploy.result == 'failure' }}; then
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "message=âŒ CI/CD Pipeline failed at deployment stage!" >> $GITHUB_OUTPUT
        elif ${{ needs.build.result == 'failure' }}; then
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "message=âŒ CI/CD Pipeline failed at build stage!" >> $GITHUB_OUTPUT
        else
          echo "status=other" >> $GITHUB_OUTPUT
          echo "message=âš ï¸ CI/CD Pipeline completed with unknown status" >> $GITHUB_OUTPUT
        fi
    
    - name: Send success notification
      if: steps.check-status.outputs.status == 'success'
      run: |
        echo "${{ steps.check-status.outputs.message }}"
        echo "ğŸŒ Application URL: http://${{ secrets.VM_HOST }}"
        echo "ğŸ“Š GitHub Actions Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        echo "ğŸ·ï¸  Deployed Tag: ${{ env.DEPLOY_TAG }}"
    
    - name: Send failure notification
      if: steps.check-status.outputs.status == 'failure'
      run: |
        echo "${{ steps.check-status.outputs.message }}"
        echo "ğŸ” Check logs at: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        echo "ğŸ’¡ For rollback, SSH to VM and run: /opt/web-calculator/rollback.sh"
        echo "ğŸŒ Current VM: ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }}"
        
        # æä¾›è¯Šæ–­å‘½ä»¤
        echo ""
        echo "ğŸ“‹ Diagnostic commands:"
        echo "1. Check Docker: ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} 'docker ps'"
        echo "2. Check logs: ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} 'cd /opt/web-calculator && docker-compose logs'"
        echo "3. Check nginx: ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} 'cd /opt/web-calculator && cat nginx/conf.d/default.conf'"
    
    - name: Send other notification
      if: steps.check-status.outputs.status == 'other'
      run: |
        echo "${{ steps.check-status.outputs.message }}"
        echo "Workflow result:"
        echo "- Test: ${{ needs.test.result }}"
        echo "- Build: ${{ needs.build.result }}"
        echo "- Deploy: ${{ needs.deploy.result }}"